import sysfrom struct import *class global_Header:    magic_num = None    this_zone = None    def set_magic_num(self, buffer):        self.magic_num = buffer    def set_this_zone(self, buffer):        self.this_zone = unpack('BBBB', buffer)class packet_header:    def __init__(self):        self.ts_sec = 0        self.ts_usec = 0        self.incl_len = 0    def set_ts_sec(self, buffer):        self.ts_sec = buffer[0] + buffer[1] * (2 ** 8) + buffer[2] * (2 ** 16) + buffer[3] * (2 ** 24)    def get_ts_sec(self):        return self.ts_sec    def set_ts_usec(self, buffer):        self.ts_usec = (buffer[0] + buffer[1] * (2 ** 8) + buffer[2] * (2 ** 16) + buffer[3] * (2 ** 24)) * (10 ** (-9))    def get_ts_usec(self):        return self.ts_usec    def set_incl_len(self, buffer):        incl_len = unpack('BBBB', buffer)        self.incl_len = incl_len[3] * (2 ** 24) + incl_len[2] * (2 ** 16) + incl_len[1] * (2 ** 8) + incl_len[0]class IP_header:    def __init__(self):        self.ip_header_len = None        self.total_len = 0        self.id = 0        self.flags = 0        self.fragment_offset = 0        self.ttl_value = 0        self.protocol = 0        self.src_ip = None        self.dst_ip = None    def set_ip_header_len(self, buffer):        self.ip_header_len = (buffer % 16) * 4    def set_total_len(self, buffer):        total_len = unpack('>H', buffer)        self.total_len = total_len[0]    def set_ID(self, buffer):        id = unpack('>H', buffer)        self.id = id[0]    def set_flags(self, buffer):        self.flags = buffer // (2 ** 4)    def set_fragment_offset(self, buffer):        offset = unpack('>H', buffer)        self.fragment_offset = (offset[0] % (2 ** 13)) * 8    def set_TTL(self, buffer):        self.ttl_value = buffer    def set_protocol(self, buffer):        self.protocol = buffer    def set_src_IP(self, buffer):        self.src_ip = unpack('BBBB', buffer)    def get_src_IP(self):        return str(self.src_ip[0]) + "." + str(self.src_ip[1]) + "." + str(self.src_ip[2]) + "." + str(self.src_ip[3])    def set_dst_IP(self, buffer):        self.dst_ip = unpack('BBBB', buffer)    def get_dst_IP(self):        return str(self.dst_ip[0]) + "." + str(self.dst_ip[1]) + "." + str(self.dst_ip[2]) + "." + str(self.dst_ip[3])class UDP_header:    def __init__(self):        self.src_port = 0        self.dst_port = 0        self.udp_header_len = 0    def set_src_port(self, buffer):        self.src_port = buffer[0] * (2 ** 8) + buffer[1]    def set_dst_port(self, buffer):        self.dst_port = buffer[0] * (2 ** 8) + buffer[1]    def set_udp_header_len(self, buffer):        length = unpack('>H', buffer)        self.udp_header_len = length[0]class ICMP_header:    def __init__(self):        self.type = 0        self.code = 0        self.seq = 0        self.orig_src_IP = None        self.orig_dst_IP = None        self.orig_src_port = 0        self.orig_dst_port = 0        self.orig_protocol = 0        self.orig_seq = 0    def set_type(self, buffer):        self.type = buffer    def set_code(self, buffer):        self.code = buffer    def set_seq_number(self, buffer):        seq_num = unpack('>H', buffer)        self.seq = seq_num[0]    def set_orig_src_IP(self, buffer):        self.src_ip = unpack('BBBB', buffer)    def get_orig_src_IP(self):        return str(self.orig_src_IP[0]) + "." + str(self.orig_src_IP[1]) + "." + str(self.orig_src_IP[2]) + "." + str(            self.orig_src_IP[3])    def set_orig_dst_IP(self, buffer):        self.dst_ip = unpack('BBBB', buffer)    def get_orig_dst_IP(self):        return str(self.orig_dst_IP[0]) + "." + str(self.orig_dst_IP[1]) + "." + str(self.orig_dst_IP[2]) + "." + str(            self.orig_dst_IP[3])    def set_orig_src_port(self, buffer):        self.orig_src_port = buffer[0] * (2 ** 8) + buffer[1]    def set_orig_dst_port(self, buffer):        self.orig_dst_port = buffer[0] * (2 ** 8) + buffer[1]    def set_orig_protocol(self, buffer):        self.orig_protocol = buffer    def set_orig_seq(self, buffer):        orig_seq = unpack('>H', buffer)        self.orig_seq = orig_seq[0]class packets:    def __init__(self):        self.packet_header = packet_header()        self.IP_header = IP_header()        self.UDP_header = UDP_header()        self.ICMP_header = ICMP_header()        self.packet_number = 0        self.payload = 0        self.timestamp = 0    def get_timestamp(self):        self.timestamp = (self.packet_header.ts_sec + self.packet_header.ts_usec) * (10 ** 3)        return self.timestamp    def set_packet_number(self, packet_num):        self.packet_number = packet_num    def get_RTT(self, packet):        return float(self.get_timestamp() - packet.get_timestamp())    def set_payload_len(self, payload):        self.payload = payloaddef read_IP_header(file, packet_num):    # read packet header    buffer = file.read(16)    packet = packets()    packet.set_packet_number(packet_num)    packet.packet_header.set_ts_sec(buffer[0:4])    packet.packet_header.set_ts_usec(buffer[4:8])    packet.packet_header.set_incl_len(buffer[8:12])    # read Ethernet header, since it doesn't need for this analysis    file.read(14)    # read IP header    buffer = file.read(20)    packet.IP_header.set_ip_header_len(buffer[0])    packet.IP_header.set_total_len(buffer[2:4])    packet.IP_header.set_ID(buffer[4:6])    packet.IP_header.set_flags(buffer[6])    packet.IP_header.set_fragment_offset(buffer[6:8])    packet.IP_header.set_TTL(buffer[8])    packet.IP_header.set_protocol(buffer[9])    packet.IP_header.set_src_IP(buffer[12:16])    packet.IP_header.set_dst_IP(buffer[16:20])    # print("packet {} incl_len :{} protocol :{} timestamp :{}".format(packet_num, packet.packet_header.incl_len, packet.IP_header.protocol, packet.get_timestamp()))    if packet.IP_header.protocol == 1:        file_read = 0        # ICMP protocol        buffer = file.read(8)        packet.ICMP_header.set_type(buffer[0])        packet.ICMP_header.set_code(buffer[1])        # ICMP error message included        if packet.ICMP_header.type == 3 or packet.ICMP_header.type == 11:            file_read += 20            buffer = file.read(20)            packet.ICMP_header.set_orig_protocol(buffer[9])            packet.ICMP_header.set_orig_src_IP(buffer[12:16])            packet.ICMP_header.set_orig_dst_IP(buffer[16:20])            orig_ip_header_len = (buffer[0] % 16) * 4            if orig_ip_header_len > 20:                file.read(orig_ip_header_len - 20)            # error message includes ICMP protocol message -> captured in Windows            if packet.ICMP_header.orig_protocol == 1:                file_read += 8                buffer = file.read(8)                packet.ICMP_header.set_orig_seq(buffer[6:8])            # error message includes UDP protocol message -> captured in Linux            elif packet.ICMP_header.orig_protocol == 17:                file_read += 8                buffer = file.read(8)                packet.ICMP_header.set_orig_src_port(buffer[0:2])                packet.ICMP_header.set_orig_dst_port(buffer[2:4])        # ICMP message sent from client        elif packet.ICMP_header.type == 8:            packet.ICMP_header.set_seq_number(buffer[6:8])        # ICMP message with echo reply -> captured in Windows        elif packet.ICMP_header.type == 0:            packet.ICMP_header.set_orig_seq(buffer[6:8])        file.read(packet.packet_header.incl_len - (42 + file_read))    elif packet.IP_header.protocol == 17:        # UDP protocol sent from client        buffer = file.read(8)        packet.UDP_header.set_src_port(buffer[0:2])        packet.UDP_header.set_dst_port(buffer[2:4])        packet.UDP_header.set_udp_header_len(buffer[4:6])        # print(packet.UDP_header.src_port, packet.UDP_header.dst_port, packet_num)        file.read(packet.packet_header.incl_len - 42)    else:        # Other than UDP or ICMP messages, these will be ignored for this program        file.read(packet.packet_header.incl_len - 34)    return packetdef read_global_header(file):    buffer = file.read(24)    global_header = global_Header()    global_header.set_magic_num(buffer[0:4])    global_header.set_this_zone(buffer[8:12])def OS_check(packets):    # sorted_packets = sorted(packets, key=lambda packet: (packet.IP_header.ttl_value, packet.packet_number))    for packet in packets:        if (packet.ICMP_header.orig_src_port != 0 and packet.ICMP_header.orig_seq == 0):            # Captured in Linux            return 1        elif (packet.ICMP_header.orig_seq != 0 and packet.ICMP_header.orig_src_port == 0):            # Captured in Windows            return 2def implement_orig_data_to_fragment(packets, packet_num):    for i in range(0, packet_num - 1):        if packets[i].IP_header.flags == 2:            for j in range(i + 1, packet_num - 1):                if packets[j].IP_header.flags == 0 and packets[j].IP_header.protocol == 17 and packets[                    i].IP_header.get_src_IP() == packets[j].IP_header.get_src_IP():                    packets[j].UDP_header.set_src_port(pack('>H', packets[i].UDP_header.src_port))                    # print(i,j, packets[i].UDP_header.src_port, packets[j].UDP_header.src_port)                    break                elif packets[j].IP_header.flags == 0 and packets[j].IP_header.protocol == 1:                    packets[j].ICMP_header.set_orig_seq(pack('>H', packets[i].ICMP_header.orig_seq))                    # print(i,j, packets[i].ICMP_header.orig_seq)                    breakdef print_inter_routers_linux(packets, packet_num, dst_IP):    print("\nThe IP addresses of the intermediate destination nodes:")    int_routers = {}    ttl = {}    for i in range(0, packet_num - 1):        if packets[i].IP_header.protocol == 17:            for j in range(i + 1, packet_num - 1):                if (packets[j].ICMP_header.type == 11 or packets[j].ICMP_header.type == 3) and packets[                    i].UDP_header.src_port == packets[j].ICMP_header.orig_src_port:                    if packets[j].IP_header.get_src_IP() not in int_routers:                        int_routers[packets[j].IP_header.get_src_IP()] = [packets[j].get_RTT(packets[i])]                        # ttl[packets[j].IP_header.get_src_IP()] = [packets[i].IP_header.ttl_value]                    else:                        int_routers[packets[j].IP_header.get_src_IP()].append(packets[j].get_RTT(packets[i]))                        # ttl[packets[j].IP_header.get_src_IP()].append(packets[i].IP_header.ttl_value)    count = 1    for ip in int_routers:        if ip != dst_IP:            print("\trouter {}: {}".format(count, ip))            # print("\trouter {}: {} ttl: {}".format(count, ip, ttl[ip]))            count += 1    return int_routersdef print_inter_routers_windows(packets, packet_num, dst_IP):    print("\nThe IP addresses of the intermediate destination nodes:")    int_routers = {}    ttl = {}    for i in range(0, packet_num - 1):        if packets[i].ICMP_header.type == 8:            for j in range(i + 1, packet_num - 1):                if (packets[j].ICMP_header.type == 0 or packets[j].ICMP_header.type == 11) and packets[                    i].ICMP_header.seq == packets[j].ICMP_header.orig_seq:                    if packets[j].IP_header.get_src_IP() not in int_routers:                        int_routers[packets[j].IP_header.get_src_IP()] = [packets[j].get_RTT(packets[i])]                        # ttl[packets[j].IP_header.get_src_IP()] = [packets[i].IP_header.ttl_value]                    else:                        int_routers[packets[j].IP_header.get_src_IP()].append(packets[j].get_RTT(packets[i]))                        # ttl[packets[j].IP_header.get_src_IP()].append(packets[i].IP_header.ttl_value)    count = 1    for ip in int_routers:        if ip != dst_IP:            print("\trouter {}: {}".format(count, ip))            # print("\trouter {}: {} ttl: {}".format(count, ip, ttl[ip]))            count += 1    return int_routersdef print_protocol(packets):    protocols = set()    for packet in packets:        protocol = packet.IP_header.protocol        if protocol == 1 or protocol == 17:            protocols.add(protocol)    print("\nThe values in the protocol field of IP headers:")    if 1 in protocols and 17 in protocols:        print("\t1: ICMP\n\t17: UDP\n")    elif 1 in protocols and 17 not in protocols:        print("\t1: ICMP\n")    elif 1 not in protocols and 17 in protocols:        print("\t17: UDP\n")def print_fragment_packet(packets, packet_num):    for i in range(0, packet_num - 1):        if packets[i].IP_header.flags == 2:            for j in range(i, packet_num - 1):                if packets[j].IP_header.flags == 0:                    print("The number of fragments created from the original datagram id {} is: {}".format(                        packets[j].IP_header.id, j - i + 1))                    print("The offset of the last fragment is: {}\n".format(packets[j].IP_header.fragment_offset))                    breakdef sd_calculator(mean, rtt_values):    deviation = [(x - mean) ** 2 for x in rtt_values]    return (sum(deviation) / len(rtt_values)) ** 0.5def print_RTT_average(src_IP, int_routers):    for ip in int_routers:        mean = sum(int_routers[ip]) / len(int_routers[ip])        sd = sd_calculator(mean, int_routers[ip])        print("The avg RTT between {} and {} is: {:.3f}ms, the s.d. is: {:.3f}ms".format(src_IP, ip, mean, sd))def print_result(packets, packet_num, type_OS):    implement_orig_data_to_fragment(packets, packet_num)    if type_OS == 1:        for packet in packets:            if packet.ICMP_header.code == 3:                print("The IP address of the source node: {}".format(packet.IP_header.get_dst_IP()))                print("The IP address of the destination node: {}".format(packet.IP_header.get_src_IP()))                src_IP = packet.IP_header.get_dst_IP()                dst_IP = packet.IP_header.get_src_IP()                break        int_routers = print_inter_routers_linux(packets, packet_num, dst_IP)    else:        for packet in packets:            if packet.ICMP_header.type == 8:                print("The IP address of the source node: {}".format(packet.IP_header.get_src_IP()))                print("The IP address of the destination node: {}".format(packet.IP_header.get_dst_IP()))                src_IP = packet.IP_header.get_src_IP()                dst_IP = packet.IP_header.get_dst_IP()                break        int_routers = print_inter_routers_windows(packets, packet_num, dst_IP)    print_protocol(packets)    print_fragment_packet(packets, packet_num)    print_RTT_average(src_IP, int_routers)def main():    packets = []    packet_num = 1    argc = len(sys.argv)    if argc < 2 or argc > 2:        print("please provide right file name")    file_name = sys.argv[1]    with open(file_name, "rb") as file:        read_global_header(file)        while True:            try:                packet = read_IP_header(file, packet_num)                if packet:                    packets.append(packet)                    packet_num += 1            except:                break    type_OS = OS_check(packets)    print_result(packets, packet_num, type_OS)if __name__ == "__main__":    main()